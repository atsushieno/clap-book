


# CLAPの基本的な仕組み

## オーディオプラグインの一般的な仕組み

### 概要

CLAPは汎用オーディオプラグインフォーマットです。汎用オーディオプラグインフォーマットは、任意のDAWで任意のプラグインを利用できるようにするために作られる規格です。オーディオプラグインは、プラグインフォーマットが規定するAPIを実装し、DAWは、プラグインフォーマットが規定するAPIの実装コードをバイナリプログラム（DLLなど）からロードします。

2022年の本書執筆時点では、オーディオプラグインフォーマットは複数の規格が並立していますが、基本的な機能は大まかには次の通りで、大きく違うものではありません。

- 動的ライブラリに類するかたちでロードでき、複数のインスタンスを生成できる
- ステレオ等のオーディオ入力とMIDI等のコントロール入力を「オーディオ処理」のサイクルで受け取って、オーディオ出力およびコントロール出力に変換する
- 外部から操作でき、変更をGUIに通知できるfloatのパラメーターがある（その他の型をサポートすることもある）
- MIDIなどの「イベント」を受け取ったり通知したりできる（オーディオ処理と連動するかしないかは規格による）
- プラグインのパラメーター等を状態として保存・復元できる
- メタデータとしてプラグイン名やベンダー名をもち、プラグインホスト（DAWなど）がシステム上に有るプラグインをリストアップできる
- ホストDAWからサブウィンドウに表示できるGUIをもつ

これらだけであれば、素朴に設計するのも実装するのもそんなに難しくはありません。特にプラグインフォーマットとはAPIであって実装コードである必要はないので、宣言してしまえば大部分の仕事は終わりです。free-audio/clapのリポジトリの内容も、ほぼAPIのみなのでシンプルです。

もちろん、適当にAPIを作っただけではプラグインでもDAWでも対応してもらえないので、実際にプラグインフォーマットを定着させるためには、それ以上の仕事をすることになります。魅力的な追加機能を用意したり、それらが多数になっても一貫性を保てたり、簡単に実装できたり…といった設計の調整力が必要になります。ここがCLAPの長所のひとつでもあります。

## CLAPプラグインのスキャンとロード

DAWユーザーがオーディオプラグインを使うとき、最初にローカル環境にインストールされているプラグインのリストを取得する必要があるのが一般的です。リストには次のスクリーンショットのような内容が含まれます。

![インストールされているオーディオプラグインのリスト](./images/audio-plugin-list.png)

これはJUCEのAudioPluginHostというプログラムに筆者が手を加えてCLAPプラグインも列挙できるようにしたもので、実用性はありません（プラグインを正しくロードできません）が、DAWを利用したことのある読者は、このようなリストをセットアップした経験があるでしょう。

第2章で説明したとおり、プラットフォームごとにCLAPプラグインを検索するパスが決められているので、その中から拡張子が`.clap`であるものを、`dlopen()`や`LoadLibrary()`などプラットフォーム別のやり方で動的ライブラリとしてロードしていきます。ひとつの`.clap`ファイルには複数のプラグインが含まれていることがあります。

### プラグインのロードとインスタンス生成

ホストを開発するとき、プラグインのライブラリをロードした後のプラグインインスタンス生成については、`include/clap/entry.h`のコードコメントを参照すると良いでしょう。このヘッダーファイルには、プラグインのエントリーポイントとなる`clap_entry`の宣言が含まれています。この宣言通りの変数を、自分のプラグインのライブラリで定義すれば、それがホストからロードされることになります。ロードしたら`init()`、正常終了時にアンロードする前には`deinit()`を呼ぶ必要があります。

実際のプラグインインスタンスの生成は`get_factory(CLAP_PLUGIN_FACTORY_ID)`という`clap_entry`のメンバー呼び出しで`clap_plugin_factory_t`型の変数を返させてから行います。この型と`CLAP_PLUGIN_FACTORY_ID`という定数は`entry.h`ではなく`plugin-factory.h`という別のヘッダーファイルで定義されています。

#### 高度な話題: 高速なプラグインのロード

CLAPは公式発表ではfast scanningをサポートしていると公言しているのですが、CLAPのメタデータは実のところライブラリに格納されていてDLL等をロードしないと取得できず、この点ではLV2に劣ります。さらに、VST 3.7.5もLV2のようにプラグインのメタデータを`moduleinfo.json`というファイルに出力できるようになったので、最新のVST3の仕組みよりも遅いことになってしまいました（とはいえ、VST3プラグインもホストも最新仕様に追従するまではしばらくかかるでしょう）。プラグインのfactoryのインスタンスさえ取得すればメタデータを取得できるので、プラグイン本体のインスタンスを生成しなくても済む、という点においてのみVSTより高速だといえることになります。DLLをロードすると全てのstaticデータの初期化が発生するため、JUCEのBinaryData初期化などでDLLのmmapロード以上のコストがかかるということもありますし、プラグインによってはこのDLLロードとメタデータ取得の時点でライセンスアクティベーションダイアログを出してくるものがあり、これらが迅速なプラグインリストの生成を邪魔してくるわけです。DLLをロードする方式だとそういった問題があるため、JSON等でメタデータを生成して解析できるようにしたほうが良い、というコミュニティ（筆者も含む）からはフィードバックが出ているのですが、開発チームは「JSONを解析しないといけなくなるから嫌だ」というレベルで否定的な見解を示しており、改善が施されるかは不透明なところです。

ちなみに、プラグインの列挙が仕組み上高速に完了するとしても、プラグインリストをキャッシュするDAWの仕組みがなくなるというとは限りません。プラグインリストキャッシュには「ロードに失敗した」プラグインをリストから除外する、いわゆるallowlist/denylistを管理することも期待されるためです。

### プラグインメタデータの定義とプラグインファクトリー

プラグインを開発するときは、ここまで説明してきたのとは「逆の」実装が必要になります。`get_factory()`関数を自分で定義し、`clap_plugin_factory_t`型の変数を返さなければなりません。この方の変数を返すためには、次の一連の関数を関数ポインターメンバーとして指定する構造体を定義しなければなりません。

- そのプラグインライブラリに含まれるプラグインの数を`get_plugin_count()`で返す
- `get_plugin_descriptor()`という関数で、指定されたプラグインのメタデータを`clap_plugin_descriptor_t`型の変数で返す
- `create_plugin()`でプラグインのインスタンスを`clap_plugin_t`型で返す

2番目の`get_plugin_descriptor()`が返す`clap_plugin_descriptor_t`には、プラグインのさまざまなメタデータが含まれることになります。ID、名前、ベンダー名、バージョン番号など典型的な情報が多いです。詳しくは`include/clap/plugin.h`に含まれている`clap_plugin_descriptor_t`の定義を参照してください。

## CLAPプラグインのオーディオ処理

TODO

https://atsushieno.hatenablog.com/entry/2022/07/05/182343


## CLAPホストとCLAPプラグイン

TODO

`clap_plugin_*_t` と `clap_host_*_t`

## オーディオスレッドとmainスレッドとそれ以外のスレッド

TODO

clap-helpersが活用できる

## CLAPの拡張機構

オーディオプラグインの拡張性 (extensibility) とは、シンプルにいえば機能追加のための仕組みです。プラグイン規格に追加機能を持ち込むには、APIを拡張しなければなりません。これを無計画に行うと、後から「やっぱりこの機能はいらなかった」とか「やっぱりこのAPIだとイマイチだから仕切り直そう」と思っても、後方互換性を全面的に破壊することになってしまいます。つまり、古いプラグインのコードが新しいプラグイン規格SDKのバージョンでビルドできなくなったりします。

VST2がこの無計画なスタイルで開発されてきましたが（20世紀に作られた仕様であり、誰もがAPIの後方互換性を強く意識するような時代ではありませんでした）、VST3ではこれが大きく変わりました。VST3ではコア機能と拡張機能を切り分けて、拡張機能はWindowsのCOM技術におけるクエリインターフェースの仕組みで動的に取得するようになりました。もし拡張機能の一部でAPIの進化が行き詰まったとしても、それ以外の部分は後方互換のままで利用できることになります。これはVST-MA (module architecture) と呼ばれる仕組みです。

よくVST3はVST2と比べて複雑だと言われますが、この拡張性に関する設計方針は、フレームワーク開発者の間では広く受け入れられていて、LV2でもCLAPでも同様の機構をCで実現しています。オーディオプラグイン規格以外でも、OpenSLなどにも見られます。

何をもってコア機能とし、何をもって拡張機能とするかは、これらモダンなプラグインフォーマットの間でも違いがあります。CLAPはだいぶ強めに「拡張機能化」を実現していて、オーディオポートやノートイベント・パラメーターイベント用ポートの定義すらも全て拡張機能で実現しています。

### CLAP拡張機能へのアクセス

CLAPでは、拡張機能がクリーンに整備されています。CLAPの拡張機能にはプラグイン拡張とホスト拡張がありますが、全てのプラグイン拡張機能が`clap_plugin_*_t`として定義されており、同様に全てのホスト拡張機能が`clap_host_*_t`として定義されています。プラグイン拡張のAPIは「プラグインが実装し、ホストが呼び出す」ものであり、ホスト拡張の機能は「ホストが実装し、プラグインが呼び出すもの」と理解しておけばOKです。

| 拡張の種類 | 実装者 | 利用者 |
|-|-|-|
|プラグイン拡張|プラグイン|ホスト|
|ホスト拡張|ホスト|プラグイン|

プラグインが実装する拡張は、`clap_plugin_factory_t`の`create_plugin()`で返される`clap_plugin_t`の`get_extension()`メンバー（関数ポインター）の実装となる関数で、IDに対応するものを返すかたちで実装します。たとえばプラグインでstateを保存する機能（パラメーターが存在するプラグインではほぼ実装することになるでしょう）を実装する場合はこうです。

```
clap_plugin_state_t state_ext{my_plugin_state_save, my_plugin_state_load}; // それぞれ関数
void* my_plugin_get_extension(const clap_plugin_t* plugin, const char* id) {
    if (!strcmp(id, CLAP_EXT_STATE))
        return &state_ext;
    ...
    return nullptr;
}
```

プラグインがホスト拡張を呼び出す方法については少し追加説明が必要でしょう。これに関連してはまず、拡張ではありませんが、CLAPのplugin factoryとなる`clap_plugin_factory_t`の`create()`の定義について説明します。

```
const clap_plugin_t *(*create_plugin)(const struct clap_plugin_factory *factory,
  const clap_host_t *host,  
  const char *plugin_id);
```

この2番目の引数は`clap_host_t*`という型になるのですが、これはホスト実装のポインターである必要はなく、プラグインが必要とするホスト機能を提供する実装でさえあれば十分です。`clap_host_t`には次のようなメンバーがあります（コメントを削っています）:

```
typedef struct clap_host {
   clap_version_t clap_version;
   void *host_data;
   const char *name;
   const char *vendor;
   const char *url;
   const char *version;
   const void *(*get_extension)(const struct clap_host *host, const char *extension_id);
   void (*request_restart)(const struct clap_host *host);
   void (*request_process)(const struct clap_host *host);
   void (*request_callback)(const struct clap_host *host);
} clap_host_t;
```

ホストのメタ情報のほか、ホスト拡張機能を取得するための`get_extension()`、ホストのmain (UI)スレッドで処理を呼び出すための`request_callback()`、オーディオ処理を開始させるための`request_process()`や`request_restart()`などが定義されています。ホスト拡張機能はこの`get_extension()`で取得して使います。

一方で、筆者はCLAPが必須拡張と任意拡張を区別しないのは問題だと考えています。特定の拡張機能がプラグインでサポートされていない時に、それでも正常にオーディオ処理を続行できるのか、それとも無効化すべきなのかは、区別できるべき情報です。

### 参考: LV2の拡張機能アクセス

LV2の拡張機能は他のプラグイン機構と比べると特殊です。RDFメタデータによる定義だけでほぼ全てが完結していてCヘッダーでは定数のURL定義しか含まれていないような拡張機能が少なからずあります。それらの拡張機能は、RDFのクエリだけでプロパティを取得したり設定できたりするように作られているため、追加のAPI定義を必要としないのです。

一方でRDFの操作によって機能を実現する仕組みは弱い型付けに基づいているため、すぐ間違ったコードを書いてしまいがちという問題があります。メタデータはコンパイル時に検証できないため、メタデータを変更してコードを書き換えないことで問題がすぐ生じます。

前回のエントリでも書きましたが、LV2のRDFメタデータ中心の拡張機能設計は、動的に変わりうるメタデータ項目の扱いをややこしくするという副作用がありました。先にスクリーンショットで列挙したLV2拡張機能のうち、Dynamic Manifest、Morph、Resize Portの一部仕様は、LV2のメタデータが静的であることから生じる問題を解決する（すなわち、動的なメタデータ定義を可能にする）ために定義された拡張機能です。

